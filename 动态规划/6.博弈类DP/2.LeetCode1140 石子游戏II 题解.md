# LeetCode1140 石子游戏II 题解

## 题目描述

亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。

亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。

在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 <= X <= 2M。然后，令 M = max(M, X)。

游戏一直持续到所有石子都被拿走。

假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。



## 分析

这是一道博弈类的问题，博弈类问题理解的一个关键就是**先后手与双方最优值的互相转化**，再加上双方都是最优决策，那么有些情况下，无需考虑谁先谁后，只需要确定状态的最优值即可，因为先后手转化之后是一个子问题。

这里的状态定义是$dp[i][j]$表示当前剩余i堆石子的时候，M为j所能拿到的最大石子数目。

**如何得到这里的状态定义的？显然，会对结果与转移造成影响的有M，此外，这里实际上是可以使用深度优先搜索来进行求解的，我们可以考虑利用这个条件。**

由于深度优先搜索在这里是解决决策分支的情况的，但是在从深度优先搜索转到动态规划的状态定义，因为M会对深度优先搜索的分支个数造成影响，所以状态定义中需要包括M。再者即使是相同状态转移方向，也可以出现多种定义：**第i个，剩余i个**，等。看什么状态定义方便。

因此，这里的状态转移方程是：
$$
dp[i][j]=\max_{x = 1, i + x <= len}^{2*M}(sum-dp[i + x][max(M, x)])
$$
**==对于博弈问题，当前的决策是基于对手的下一次最好决策做出来的，最优决策的意思就是遍历所有可行解，挑选出最优的值。正是由于这个对手下一次最好决策，所以博弈类问题很多状态定义是剩余XX。==**

## 代码

```c++
int stoneGameII(vector<int>& piles) {
    int len = piles.size();
    int sum = 0;
    // 多维vector都初始化方法
    vector<vector<int>> dp(len + 1, vector<int>(len + 1, 0));
    for (int i = len - 1; i >= 0; i--) {
        sum += piles[i];
        for (int M = 1; M <= len; M++) {
            if (i + 2 * M >= len) {
                dp[i][M] = sum;
                continue;
            } 
            for (int x = 1; i + x <= len && x <= 2 * M; x++) {
                //当前的所有后缀和-下一次对方可能的最优解。
                dp[i][M] = max(dp[i][M], sum - dp[i + x][max(M, x)]);
            }
        }
    }
    return dp[0][1];
}
```

