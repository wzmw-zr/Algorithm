# LeetCode309 最佳股票买卖时机含冷冻期 题解

## 题目描述

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。



## 分析

这道题目实际上就是最佳股票买卖时机的一个变形，都是用动态规划求解，状态定义为$dp[i][j]$表示第i天处于j条件下的最大值，只是现在每天的状态会有四种情况：买入、卖出、**冷冻期(实际上还是无操作)**、无操作。

**冷冻期实际上还是无操作**，意味着某一天卖出，后一天就是没有股票的保持状态，0表示没有股票，1表示持有股票，**2表示当天卖出**(不要定义为前一天卖出股票处于冷冻期，因为这样会造成初始化不完全，很难算)。

状态转移方程：
$$
\begin{aligned}
&dp[i][0]=\max(dp[i-1][0],dp[i-1][2])\\
&dp[i][1]=\max(dp[i-1][1],dp[i-1][0]-prices[i-1])\\
&dp[i][2]=dp[i-1][1]+prices[i-1]
\end{aligned}
$$


## 代码

```c++
int maxProfit(vector<int>& prices) {
    int p_len = prices.size();
    if (p_len == 0) return 0;
    int dp[p_len + 5][3];
    memset(dp, 0, sizeof(dp));
    dp[0][0] = 0;
    dp[0][1] = dp[0][2] = -0x3f3f3f3f;
    for (int i = 1; i <= p_len; i++) {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][2]);
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1]);
        dp[i][2] = dp[i - 1][1] + prices[i - 1];
    }
    return max(dp[p_len][0], dp[p_len][2]);
}
```





