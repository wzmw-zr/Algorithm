# LeetCode174 地下城游戏题解

## 题目描述

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。



## 分析

这是一道明显的二维动态规划类型的题目。之前我是采用深度优先搜索，会超时。

在使用深度优先搜索的过程中，结果实际上是与从起点到终点的每一条路径的过程中存在的部分路径的最小负值的最大值有关。

这里如果设状态$dp[i][j]$表示从起点到(i，j)的最小生命值的话，此时我们希望从出发点到当前点的路径和尽可能大，而从出发点到当前点所需的最小初始值尽可能小，**此时有两个重要程度相同的参数同时影响后续的决策，这样的动态规划是不满足“无后效性”。**

因此在这里我们设**状态$dp[i][j]$表示从(i，j)到终点所需要的最小初始值**，即，当我们到坐标(i，j)时，如果路径和不小于$dp[i][j]$，那么就可以到达终点。

因此，状态转移方程就是：
$$
dp[i][j] = \max(min(dp[i+1][j],dp[i][j+1]) - dungeon(i,j),1)
$$


## 代码

```c++
int calculateMinimumHP(vector<vector<int>>& dungeon) {
    int x_len = dungeon.size(), y_len = dungeon[0].size();
    // 处理一些边界的情况，可以简化代码的初始化方式
    vector<vector<int>> dp(x_len + 5, vector<int>(y_len + 5, 0x3f3f3f3f));
    dp[x_len][y_len - 1]= dp[x_len - 1][y_len] = 1;
    for (int i = x_len - 1; i >= 0; i--) {
        for (int j = y_len - 1; j >= 0; j--) {
            int mmin = min(dp[i + 1][j], dp[i][j + 1]);
            dp[i][j] = max(mmin - dungeon[i][j], 1);
        }
    }
    return dp[0][0];
}
```

