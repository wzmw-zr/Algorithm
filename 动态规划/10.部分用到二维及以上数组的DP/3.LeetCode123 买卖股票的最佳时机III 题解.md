# LeetCode123 买卖股票的最佳时机III 题解

## 题目描述

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。



## 分析

股票买卖问题在LeetCode上一共有6道题目，实际上这类问题有共性，将问题泛化就变成了：**限制最大交易次数为k，求股票买卖的最大利润。**

而且，**==股票买卖问题也是包含隐式决策的问题==，每天都有三种选择：买入、卖出、无操作，但是并不是每天都可以任意选择这三种选择的，因为卖出操作必须在买入操作之后，买入造作也是需要在卖出操作之后才可以进行。**

**每一天持有股票的状态**也是会影响决策的，因此，在每一天，分成两类：有股票，没股票。

在考虑天数，我们定义状态$dp[i][j][k]$表示在第i天，至多进行j次交易，根据k的值判断是否有股票，所能获得的最大利润。

因此，状态转移方程就是：
$$
dp[i][j][0]=\max(dp[i-1][j][0],dp[i-1][j][1] + prices[i])\\
dp[i][j][1]=\max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i])
$$


## 代码

```c++
int maxProfit(vector<int> &prices) {
    int p_len = prices.size();
    int dp[p_len + 5][5][5];
    memset(dp, 0, sizeof(dp));
    // 初始条件：第0天如果无股票，为0,由于不可能持有股票，所以do[0][i][1]应当为负无穷
    for (int i = 0; i <= 2; i++) {
        dp[0][i][0] = 0;
        dp[0][i][1] = INT32_MIN; 
    }
    for (int i = 1; i <= p_len; i++) {
        dp[i][0][0] = max(dp[i - 1][0][0], dp[i - 1][0][1] + prices[i - 1]);
        dp[i][0][1] = max(dp[i - 1][0][1], dp[i - 1][1][0] - prices[i - 1]);
        dp[i][1][0] = max(dp[i - 1][1][0], dp[i - 1][1][1] + prices[i - 1]);
        dp[i][1][1] = max(dp[i - 1][1][1], dp[i - 1][2][0] - prices[i - 1]);
    }
    return dp[p_len][0][0];
}
```

