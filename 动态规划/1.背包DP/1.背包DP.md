# 背包DP

背包问题的描述大致如下：

有$n$个物品和一个容量为$W$的背包，每个物品有重量$w_i$ 和价值$v_i$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

**状态即问题，取和不取即选择。**

## 一、0-1背包

每个物体只有 2 种可能的状态（取与不取），这类问题便被称为“0-1 背包问题”。

**设DP状态$f_{i,j}$为在只能放前$i$个物品的情况下，容量为$j$的背包所能达到的最大总价值。**

其状态转移方程是$f_{i,j}=max(f_{i-1,j},f_{i-1,j-w_i}+v_i)$，注意$j$与$w_i$的大小与条件判断。

这里直接使用二维数组记录状态会导致MLE，可以**使用滚动数组进行优化。**

进一步，由于对$f_i$有影响的只有$f_{i-1}$，这一点可以通过填表看出来，可以去掉物品个数那一个维度。直接**使用$f_i$来表示处理到当前物品时背包容量为i的最大价值。**得出方程：

$f_j=max(f_j,f_{j-w_i}+v_i)$ 。

**这个状态转移方程十分重要，大部分背包问题的转移方程都是在此基础上推导出来的。**

核心代码：

```c++
for (int i = 1; i <= n; i++) {
    // 从最大容量到最小容量，这是由问题与子问题的依赖关系决定的
    for (int j = all; j >= 1; j--) {
        if (j >= w[i]) ans[j] = max(ans[j], ans[j - w[i]] + v[i]);
    }
}
```



## 二、完全背包

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

我们可以借鉴 0-1 背包的思路，进行状态定义：设$f_{i,j}$为只能选前 i个物品时，容量为 j的背包可以达到的最大价值。

**朴素做法：对于第i件物品，枚举其选了多少个来进行状态转移，时间复杂度为$O(n^3)$。**状态转移方程如下：
$$
f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k*w_i}+k*v_i)
$$
可以发现，**对于$f_{i,j}$，只要通过$f_{i,j-w_i}$转移就可以了，这样转移时$f_{i,j-w_i}$已经由$f_{i, j-2*w_i}$更新过，那么$f_{i, j-w_i}$就已经是充分考虑过第$i$件物品所选次数之后的最优结果**。已经利用了局部最优子结构性质重复使用了之前的枚举过程。状态转移方程如下：
$$
f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$
这样就是与$0,1$背包第一版转移方程类似了，同样，根据这个可以再进行空间压缩，其转移方程如下：
$$
f_j=max(f_j, f_{j-w_i}+v_i)
$$
完全背包的核心代码如下：

```c++
for (int i = 1; i <= n; i++) {
    // 从小到大的空间，这是根据完全背包的性质与依赖关系决定的
    for (int j = 1; j <= all; j++) {
        if (j >= w[i]) ans[j] = max(ans[j], ans[j - w[i]] + v[i]);
    }
}
```



## 三、多重背包

多重背包也是0,1背包的一个变式，与 0-1 背包的区别在于每种物品 y 有$k_i$个，而非1个。

一个和完全背包的朴素解法一样的方法：**==把“每种物品选$k_i$次”等价转换为“有$k_i$个相同的物品，每个物品选一次”。这样就转换成了一个 0-1 背包模型 。==**其状态转移方程如下：
$$
f_{i,j}=\max_{k=0}^{k_i}(f_{i-1, j-k*w_i}+k*v_i)\quad(j\ge k*w_i)
$$
时间复杂度为$O(nW\sum k_i)$。

### 1.单调队列优化多重背包

单调队列优化动态规划问题的基本形态：**当前状态的所有值可以从上一个状态的某个连续的段的值得到，要对这个连续的段进行`RMQ`操作，相邻状态的段的左右区间满足非降的关系。**这个结论需要写出状态转移方程之后才可以分析出来。

现在来分析朴素解法的多重背包的状态转移方程**：$f_{i,j}$可以从$f_{i-1,j},f_{i-1,j-w_i},f_{i-1,j-2*w_i}...f_{i-1,j-k*w_i}$转移而来，同样的，$f_{i,j-w_i}$从$f_{i-1,j-w_i},f_{i-1,j-2*w_i},f_{i-1,j-3*w_i},...f_{i-1,j-k*w_i}$转移而来。可以看到，这两者之间存在着重复的过程，因此可以进行优化。**

从上面的分析中，可以发现这是将容量按照模$w_i$运算划分为了$w_i$组等价类。

但是**由于后面的$k*v_i$中的k是一个变化的量，导致了$f_{1,j-k*w_i}$无法单独形成一个有效的单调队列，那么==进行变量代换使其能够变为有效的单调队列的形式==**。

经过分析可以发现**转移方程对于给定的$i$，起到影响作用的只有$w_i$前的系数与余数，分别令为x和y**，因此令$g_{x,y}=f_{i,x*w_i+y},g_{x,y}^{'}=f_{i-1,x*w_i+y}$，那么转移方程就可以表示为：
$$
g_{x,y}=\max_{k=0}^{k_i}(g^{'}_{x-k,y}+k*v_i)
$$
设$G(x,y)=g^{'}_{x,y}-x*v_i$(用减法是为了在替换时消去 $k*v_i$)，则方程可以表示为 ：
$$
g_{x,y}=\max_{k=0}^{k_i}(G_{x-k,y})+x*v_i
$$
在实际编码过程中，按照相同模$w_i$的余数进行分组并对每个分组建立单调队列，$G_{x,y}$可以$O(1)$计算 (决策)，因此对于固定的$y$，我们可以在$O(\lfloor\frac{W}{w_i}\rfloor)$时间内计算出$g_{x,y}$，因此求出所有$g_{x,y}$的复杂度为$O(\lfloor\frac{W}{w_i}\rfloor)*O(w_i)=O(W)$。这样，总的时间复杂度就降为了$O(nW)$



## 四、混合背包

混合背包就是将前面三种的背包问题混合起来，有的只能取一次，有的能取无限次，有的只能取 k次。**这实际上就是判断物品类型，选择对应的处理方式就可以了，思想都是一样的。**伪代码如下：

```c++
for (循环物品种类) {
  if (是 0 - 1 背包)
    套用 0 - 1 背包代码;
  else if (是完全背包)
    套用完全背包代码;
  else if (是多重背包)
    套用多重背包代码;
}
```



## 五、二维费用背包

如果选择一种物品会消耗两种价值(如费用与时间)。**只需要数组增加一个维度，同时转移两个价值即可。**(再开一维存放物品编号就不合适了，因为容易 MLE)

核心代码：

```c++
// 这是一道二维费用的0-1背包核心代码，完全背包与多重背包与之类似，只是转移方程不同
for (int k = 1; k <= n; k++) { 
  for (int i = m; i >= mi; i--)    //对经费进行一层枚举
    for (int j = t; j >= ti; j--)  //对时间进行一层枚举
      dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + 1);
}
```



## 六、分组背包

所谓分组背包，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。

这其实是**从“在所有物品中选择”变成了“从当前组中选择”**，于是就**对每一组进行一次 0-1/完全/多重背包就可以了。**

核心代码：

```c++
// 这是一道分组背包的0-1背包代码题，注意一下循环方向问题就可以了
for (int k = 1; k <= ts; k++)          //循环每一组
  for (int i = m; i >= 0; i--)         //循环背包容量
    for (int j = 1; j <= cnt[k]; j++)  //循环该组的每一个物品
      if (i >= w[t[k][j]])
        dp[i] = max(dp[i],
                    dp[i - w[t[k][j]]] + c[t[k][j]]);  //像0-1背包一样状态转移
```



## 七、有依赖的背包

这种背包问题其实就是**如果选第 i件物品，就必须选第 j 件物品**，保证不会循环引用，一部分题目甚至会出现多叉树的引用形式。为了方便，就**称不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。**

解法待补充。



## 八、泛化物品的背包

这种背包，**没有固定的费用和价值，它的价值是随着分配给它的费用而定**。在背包容量为 $V$的背包问题中，当分配给它的费用为$v_i$时，能得到的价值就是$h(v_i)$。这时，**将固定的价值换成函数的引用即可。**



## 九、背包问题的变种

### 1.输出方案

输出方案其实就是**记录下来背包中的某一个状态是怎么推导出来的**。可以**使用$g_{i,v}$表示第$i $件物品占用空间为$v$的时候是否选择了此物品。然后在转移时记录是选用了哪一种策略。**

输出时的伪代码：

```c++
int v = V;  //记录当前的存储空间
for (
    从最后一件循环至第一件)  //因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环
{
  if (g[i][v]) {
    选了第 i 项物品;
    v -= 第 i 项物品的价值;
  } else
    未选第 i 项物品;
}
```



### 2.求方案数

对于给定的一个背包容量、物品费用、其他关系等的问题，求装到一定容量的方案总数。

这种问题就是**把求最大值换成求和即可。**

以0-1背包问题为例，转移方程就变成了：
$$
dp_j=\sum(dp_j,dp_{j-c_i})
$$
初始条件：$dp_0=1$

因为当容量为0时也有一个方案：什么都不装。



### 3.求最优方案总数



### 4.求第k优解

