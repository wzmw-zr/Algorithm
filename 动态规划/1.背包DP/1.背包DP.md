# 背包DP

背包问题的描述大致如下：

有$n$个物品和一个容量为$W$的背包，每个物品有重量$w_i$ 和价值$v_i$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

**状态即问题，取和不取即选择。**

## 一、0-1背包

每个物体只有 2 种可能的状态（取与不取），这类问题便被称为“0-1 背包问题”。

**设DP状态$f_{i,j}$为在只能放前$i$个物品的情况下，容量为$j$的背包所能达到的最大总价值。**

其状态转移方程是$f_{i,j}=max(f_{i-1,j},f_{i-1,j-w_i}+v_i)$，注意$j$与$w_i$的大小与条件判断。

这里直接使用二维数组记录状态会导致MLE，可以**使用滚动数组进行优化。**

进一步，由于对$f_i$有影响的只有$f_{i-1}$，这一点可以通过填表看出来，可以去掉物品个数那一个维度。直接**使用$f_i$来表示处理到当前物品时背包容量为i的最大价值。**得出方程：

$f_j=max(f_j,f_{j-w_i}+v_i)$ 。

**这个状态转移方程十分重要，大部分背包问题的转移方程都是在此基础上推导出来的。**

核心代码：

```c++
for (int i = 1; i <= n; i++) {
    // 从最大容量到最小容量，这是由问题与子问题的依赖关系决定的
    for (int j = all; j >= 1; j--) {
        if (j >= w[i]) ans[j] = max(ans[j], ans[j - w[i]] + v[i]);
    }
}
```



## 二、完全背包

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

我们可以借鉴 0-1 背包的思路，进行状态定义：设$f_{i,j}$为只能选前 i个物品时，容量为 j的背包可以达到的最大价值。

**朴素做法：对于第i件物品，枚举其选了多少个来进行状态转移，时间复杂度为$O(n^3)$。**状态转移方程如下：
$$
f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k*w_i}+k*v_i)
$$
可以发现，**对于$f_{i,j}$，只要通过$f_{i,j-w_i}$转移就可以了，这样转移时$f_{i,j-w_i}$已经由$f_{i, j-2*w_i}$更新过，那么$f_{i, j-w_i}$就已经是充分考虑过第$i$件物品所选次数之后的最优结果**。已经利用了局部最优子结构性质重复使用了之前的枚举过程。状态转移方程如下：
$$
f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$
这样就是与$0,1$背包第一版转移方程类似了，同样，根据这个可以再进行空间压缩，其转移方程如下：
$$
f_j=max(f_j, f_{j-w_i}+v_i)
$$
完全背包的核心代码如下：

```c++
for (int i = 1; i <= n; i++) {
    // 从小到大的空间，这是根据完全背包的性质与依赖关系决定的
    for (int j = 1; j <= all; j++) {
        if (j >= w[i]) ans[j] = max(ans[j], ans[j - w[i]] + v[i]);
    }
}
```



## 三、多重背包

多重背包也是0,1背包的一个变式，与 0-1 背包的区别在于每种物品 y 有$k_i$个，而非1个。

一个和完全背包的朴素解法一样的方法：**==把“每种物品选$k_i$次”等价转换为“有$k_i$个相同的物品，每个物品选一次”。这样就转换成了一个 0-1 背包模型 。==**其状态转移方程如下：
$$
f_{i,j}=\max_{k=0}^{k_i}(f_{i-1, j-k*w_i}+k*v_i)
$$
时间复杂度为$O(nW\sum k_i)$。