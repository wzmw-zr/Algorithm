# LeetCode 5 最长回文子串 Manacher算法

## 题目描述

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

## 分析

最长回文子串可以使用暴力法，动态规划，Manacher算法进行求解，其中Manacher算法效率最高。

## 代码

```c++
// 首先，回文串可以分为奇数长度的和偶数长度的，通过填充特殊字符可以转化为容易求解的奇数长度
string get_new_str(string s) {
    string new_s = "#";
    for (int i = 0; s[i]; i++) {
        new_s += s[i];
        new_s += "#";
    }
    return new_s;
}

string longestPalindrome(string s) {
    int r[2010] = {0}, ans = 0, ind = 0;
    string new_s = get_new_str(s);
    // j表示位置最靠后的回文半径最长的关键回文中心，i是当前的回文中心，p是右边最远的回文半径可以达到的位置
    for (int i = 0, j = 0, p = 0; new_s[i]; i++) {
        r[i] = 1;
        // 如果i处于回文中心范围内，就可以根据i的对称点来计算i的最大回文半径长度
        if (i <= p && i + r[2 * j - i] - 1 < p) r[i] = r[2 * j - i];
        else {
            // 否则，重新计算i的最大回文半径长度
            r[i] = max(1, p - i + 1);
            while (i >= r[i] && i + r[i] < new_s.size() && new_s[i + r[i]] == new_s[i - r[i]]) r[i]++;
        }
        // 如果新的回文右边界超出当前的回文右边界，那么就更新数据
        if (i + r[i] - 1 > p) j = i, p = i + r[i] - 1;
        // 计算最长回文半径与回文中心的位置
        if (r[i] > ans) {
            ans = r[i], ind = i;
        }
    }
    string sub_str = new_s.substr(ind - ans + 1, 2 * ans - 1);
    string ret = "";
    for (int i = 1; i < sub_str.size(); i += 2) ret += sub_str[i];
    return ret;
}
```

