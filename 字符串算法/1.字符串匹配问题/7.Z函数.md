# Z函数(扩展KMP)

## 一、Z函数的定义

假设我们有一个长度为n的字符串s，该字符串的Z函数是一个长度为n的数组，其中第i个元素为满足从位置i开始且为s前缀的字符串的最大长度，即**$z[i]$为s和从i开始的后缀的最大公共前缀长度。**



## 二、计算Z函数的朴素算法

计算Z函数的朴素算法就是从从每一个位置开始依次从字符串开头比较，时间复杂度为$O(n^2)$。

```c++
vector<int> z_function(string s) {
    int n = s.size();
    vector<int> z(n, 0);
    for (int i = 1; i < n; i++) {
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;
    }
    return z;
}
```



## 三、计算Z函数的高效算法

计算Z函数的高效算法与Manacher算法有点类似。

我们按照从$i = 1$到$n-1$的顺序计算$z[i]$。定义**匹配段**为同s的一个前缀相同的那些子串，即，所求Z函数的第i个元素$z[i]$为从位置i开始的匹配串的长度，其终止位置位于$i + z[i] - 1$。

我们将始终保持**$[l,r]$为最靠右的匹配段**。即，在所有已探测到的匹配段中，我们将保持结尾最靠右的那一个。另一方面，**下标r可被认为是字符串s已被算法扫描的边界**，任何超过该点的字符都是未知的，**超过算法扫描边界的字符采用朴素算法**。

假设当前要计算的下一个Z函数值的下标为i，则有两种情况：

+ $i > r$：当前位置在我们已处理位置之外。

  接下来使用朴素算法来计算$z[i]$，注意如果最后$z[i]>0$，我们需要更新最靠右的匹配段的下标，因为新的$r=i+z[i]-1$一定比之前的r优。

+ $i\le r$ ：当前位置位于当前匹配段$[l,r]$内。

  那么我们可以用已经计算过的Z函数值来”初始化“$z[i]$。

  可以注意到$s[l..r]$和$s[0..r-l]$匹配，这意味着作为$z[i]$的一个初始近似，我们**可以直接使用对应于段$s[0..r-l]$中已经计算过的Z函数值，即$z[i-l]$。**

  + 如果$z[i-l]=0$那么意味着$suf(s,i-l)$和s最长公共前缀长度为0，直接转成朴素算法。
+ 如果$z[i-l]<r-i+1$，那么意味着$s$和$suf(s,i-l)$虽然有公共前缀，但是长度不大。
  + 但是，**$z[i-l]$的值可能比较大，将其应用到位置i结果可能会超过下标r，因此，需要进行”截断“操作。**
  
  因此，正确的$z[i]$的初始近似为：$z[i]=\min(r-i+1,z[i-l])$。在初始化后，尝试使用**朴素算法**增加$z[i]$的值，因为宏观来讲，对于边界r之后的事情，我们无法得知段是否会继续匹配还是失配。

```c++
vector<int> z_function(string s) {
    int n = s.size();
    vector<int> z(n);
    // 从下标i = 1开始，l，r初始化为0
    for (int i = 1, l = 0, r = 0; i < n; i++) {
        // 初始化z[i]，如果i > r则为0,否则，为r - i + 1和z[i - l]中的较小值，这是考虑到截断操作
        z[i] = (i > r) ? 0 : min(r - i + 1, z[i - l]);
        // 朴素算法
        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;
        // 更新最靠右的和s的公共最长前缀的范围
        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;
    }
    return z;
}
```

