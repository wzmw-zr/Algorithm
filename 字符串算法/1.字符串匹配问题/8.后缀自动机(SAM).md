# 后缀自动机(SAM)

约定$\sum$为字符集，$|\sum|$为字符集大小，对于一个字符串$s$，记$|s|$为其长度。

## 一、后缀自动机概述

**后缀自动机SAM(suffix automation)**可以理解为给定字符串的**==所有子串的压缩形式==**。SAM将所有的这些信息以高度压缩的形式储存，对于一个长度为n的字符串，其空间复杂度为$O(n)$，此外，构造SAM的时间复杂度仅为$O(n)$。准确地说，**一个SAM最多有$2n-1$个节点和$3n-4$条转移边。**

可以通过SAM在线性时间内解决的字符串问题：

+ **在一个字符串中搜索一个字符串的所有出现位置。**
+ **计算给定的字符串中有多少个不同的子串。**



## 二、后缀自动机SAM的定义

**字符串s的SAM是一个==接受s的所有后缀的最小DFA==(确定性有限状态自动机)。**

换句话说：

+ SAM是一张有向无环图。**结点被称作状态，边被称作状态间的转移。**
+ 图存在一个**源点$t_0$，称作初始状态**，其他各结点均可从$t_0$出发到达。
+ **每个转移都标有一些字母**，从一个结点出发的所有转移均不同。
+ **存在一个或多个终止状态**。如果我们从初始状态$t_0$出发，最终转移到了一个终止状态，则**路径上的所有转移连接起来一定是字符串s的一个后缀**。s的**==每一个后缀均可用一条从$t_0$到某个终止状态的路径构成。==**
+ 在所有满足上述条件的自动机中，SAM的节点数是最少的。



### 1.子串的性质

SAM最简单，也最重要的性质是，它**包含关于字符串s的所有子串的信息**，**任意==从初始状态$t_0$开始的路径==，如果我们==将转移路径上的标号写下来，都会形成$s$的一个子串==**。反之每个s的子串对应从$t_0$开始的某条路径。

为了简化表达，我们称**子串对应一条路径(从$t_0$开始，由一些标号构成这个子串)**。反过来，我们说**任意一条路径对应它的标号构成的字符串。**

**==到达某个状态的路径可能不止一条==，因此，我们说==一个状态对应一些字符串的集合==，这个集合的元素对应这些路径。**



## 三、构造SAM的一些概念

构造SAM过程中的一些重要概念：转移，后缀链接，结束位置(状态、等价类)。

### 1.结束位置`endpos`

我们在实际编程时是不会记录`endpos`的，但是`endpos`的概念有助于我们理解算法流程，因为**部分状态对应的`endpos`是会随着新字符的加入而发生改变的。**



> 我们在每次在字符串末尾增加新的字符时，必定会增加一个`endpos`为最后一个字符位置的状态，**至少新的字符串本身就对应一个`endpos={last_ind}`的状态，因为这个字符串之前从来没有出现过**，而这个状态就是新的后缀的状态，**==通过建立新的后缀指针link，可以在别的状态中增加这个`endpos`中的内容。==**
>
> **根据之前的后缀状态last遍历其后缀指针时，实际上就是==建立新的转移，更新部分`endpos`中的内容(有时会根据子串长度对状态进行拆分)。==**
>
> **因此，==`endpos`是和子串的长度密切相关的。==**



考虑字符串$s$的任意非空子串$t$，我们**记$endpos(t)$为在字符串$s$中$t$的==所有结束位置==**(假设对字符串中**字符的编号从零开始**)。

**两个子串$t_1$和$t_2$的$endpos$集合可能相等：**$endpos(t_1)=endpos(t_2)$。**==这样字符串$s$的所有非空子串都可以根据它们的$endpos$集合被分为若干等价类==**。

显然，**SAM中的==每一个状态对应一个或多个$endpos$相同的子串==。**换句话说，**$SAM$中的==状态数等于所有子串的等价类的个数==**，再加上初始状态。SAM的状态个数等价于$endpos$相同的一个或多个子串所组成的集合个数+1。 

关于`endpos`的值的一些重要结论：

1. **引理1**：字符串s的两个非空子串$u$和$w$(假设$|u|\le|w|$)的`endpos`相同，当且仅当**字符串$u$在$s$中的每次出现，都是以$w$后缀的形式存在的。**

   > 这个引理的证明是显然的。

2. **引理2**：考虑两个非空子串$u$和$w$(假设$|u|\le|w|$)。那么要么$endpos(u)\cap endpos(w)=\empty$，要么$endpos(w)\subseteq endpos(u)$，取决于$u$是否为$w$的一个后缀：
   $$
   \left\{
   \begin{array}{**lr**}
   endpos(w) \subseteq endpos(u) \qquad if\;u\;is\;a\;suffix\;of\;w\\
   endpos(w) \cap endpos(u) = \emptyset \qquad otherwise
   \end{array}
   \right.
   $$

   > **证明：**
   >
   > 如果集合$endpos(u)$与$endpos(w)$有至少一个公共元素，那么可以得出**字符串$u$与$w$在相同位置结束，$u$是$w$的一个后缀。**所以周期每次$w$出现的位置，子串$u$也会出现。但是子串$u$出现的地方$w$不一定出现，所以$endpos(w) \subseteq endpos(u)$。

3. **引理3**：考虑一个$endpos$等价类，将类中的所有子串按照长度非递增的顺序排列。每个子串都不会比它前一个子串长，于此同时每个子串也是它前一个子串的后缀。即，**对于同一等价类的任意两字串，较短者为较长者的后缀**，且该**等价类中的子串长度恰好覆盖整个区间$[x,y]$。**

   > **证明：**
   >
   > 如果$endpos$等价类中只包含一个子串，引理显然成立。
   >
   > 下面讨论子串元素个数大于1的等价类。
   >
   > 由引理1,`endpos`相同的两个非空子串，即根据$endpos$等价的字符串中，较短者总是较长者的真后缀，**因此，等价类中没有等长的字符串。**
   >
   > 记$w$为等价类中最长的字符串、$u$为等价类中最短的字符串。由引理1,字符串$u$是字符串$w$的真后缀。现在考虑长度在区间$[|u|,|w|]$中的$w$的任意后缀，显然，这个后缀也在同一等价类中，因为这个后缀只能在字符串s中以$w$的一个后缀的形式存在(也因为较短的后缀$u$在$s$中只以$w$的后缀的形式存在)。




### 2.后缀链接link

考虑SAM中某个不是$t_0$的状态$v$。我们已经知道，**状态$v$对应于具有相同`endpos`的等价类。**定义$w$是这些字符串中最长的一个，则等价类中其他的字符串都是$w$的后缀。

此外，字符串$w$的按长度降序排列的前几个后缀包含在这个等价类，**其余后缀(至少有一个空后缀)在其他等价类中**，记$t$为不在$w$等价类中的最长后缀，之后**将状态$v$的后缀链接link连接到$t$对应的状态上。**

换句话说，**一个后缀链接$link(v)$连接到对应于$w$的具有不同$endpos$的最长后缀的等价类的状态。**

我们假设初始状态$t_0$对应于它自己这个等价类(只包含一个空字符串)。为了方便，我们规定$endpos(t_0)=\{-1,0,...,|S|-1\}$。

1. **引理4**：所有后缀链接构成一棵根节点为$t_0$的树。

   > **证明：**
   >
   > 考虑任意不是$t_0$的状态$v$，**后缀链接$link(v)$连接到的状态对应于严格更短的字符串**。因此，**沿后缀链接移动，我们总是能到达对应空串的初始状态$t_0$**。

2. **引理5**：通过`endpos`集合构造的树**(每个子节点的subset都包含在父节点的subset中**)与通过后缀链接link构造的树相同。

   > **证明**：
   >
   > 根据引理二，任意一个SAM的`endpos`集合形成了一棵树(**因为两个集合要么完全没有交集要么其中一个是另一个的子集**)。
   >
   > 考虑任意不是$t_0$的状态$v$以及后缀链接$link(v)$，由后缀链接和引理2,我们可以得到:
   > $$
   > endpos(v)\subseteq endpos(link(v))
   > $$

**==后缀链接构成的树本质上是$endpos$集合构成的一棵树。==**



### 3.结论

+ s的**子串可以根据它们的结束位置`endpos`话分成多个等价类。**

+ SAM由初**始状态$t_0$和与每一个`endpos`等价类对应的每个状态组成。**

+ 对于**每一个状态$v$，一个或多个子串与之匹配**。我们记$longest(v)$为其中最长的一个字符串，记$len(v)$为其长度。类似地，记$shortest(v)$为最短的子串，它的长度为$minlen(v)$。那么**对应这个状态的所有字符串都是字符串$longest(v)$的不同的后缀，且所有字符串的长度恰好覆盖区间$[minlen(v),len(v)]$中的每一个整数。**

+ 对于任意不是$t_0$的状态$v$，定义**后缀链接为连接到对应字符串$longest(v)$的长度为$minlen(v)-1$的后缀的一条边**。**从根结点$t_0$出发的后缀链接可以形成一棵树。这棵树也表示`endpos`集合间的包含关系。**

+ 对于$t_0$以外的状态$v$，可用后缀链接$link(v)$表达$minlen(v)$：
  $$
  minlen(v)=len(link(v))+1
  $$

+ 如果我们**从任意状态$v_0$开始顺着后缀链接遍历，总会到达初始状态$t_0$。**这种情况下我们可以得到一个互不相交的区间$[minlen(v_i),len(v_i)]$的序列，且它们的并集形成了连续的区间$[0,len(v_0)]$。



## 四、线性时间构造SAM的算法

**构造SAM的算法是在线算法**，我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护SAM。

**==构造SAM需要注意理解的概念：转移，后缀链接，`len`==**。

为了保证线性的空间复杂度，我们将**只保存`len`和`link`的值和每个状态的转移列表**，我们不会标记终止状态。



### 1.构造SAM的算法步骤

一开始SAM只包含一个状态$t_0$，编号为0(其他状态的编号为1，2，...)。为了方便，**对于状态$t_0$我们指定$len=0,link=-1$(-1表示虚拟状态)。**

那么，任务转化为实现给当前字符串添加一个字符c的过程。算法流程如下：

+ 令**$last$为添加字符c之前，整个字符串对应的状态**(一开始我们设$last=0$，算法的最后一步更新$last$)。

+ **创建一个新的状态$cur$，并将$len(cur)$赋值为$len(last)+1$，**在这时$link(cur)$的值未知。

  > 增加了一个字母，因为`endpos`可以往后移动1位，新的子串的长度确实会更长，那么就将其赋值为$len(last)+1$。

+ 从状态$last$开始，按照以下流程进行：如果还没有到字符c的转移，我们就添加一个到状态$cur$的转移，遍历后缀链接。如果在某个点已经存在到字符c的转移，我们就停下来，并将这个状态标记为p。

  + 如果没有找到这样的状态p，我们就到达了虚拟状态-1,我们将$link(cur)$赋值为0并退出。

  + 假设现在我们找到了一个状态p，其可以通过字符c转移，我们将转移到的状态标记为q。

    现在我们分类讨论两种情况：要么$len(p)+1=len(q)$，要么不是。

    + 如果$len(p)+1=len(q)$，我们只要将$link(cur)$赋值为q并退出。

    + 否则我们需要 **复制** 状态q，**创建一个新的状态clone，复制q的除了$len$的值以外的所有信息(后缀链接和转移)**。我们**将$len(clone)$赋值为$len(p)+1$。**

      复制之后，我们将后缀链接从`cur`指向`clone`，也从`q`指向`clone`。

      最终我们需要**使用后缀链接从状态p往回走，只要存在一条通过p到状态q的转移，就将该转移重定向到状态clone。**

  + 以上三种情况，在完成这个过程之后，我们**将last的值更新为状态`cur`。**

如果我们还想知道哪些状态是**终止状态**而哪些不是，我们可以**在为字符串s构造完整的SAM后找到所有的终止状态**。为此，我们**从对应整个字符串的状态(存储在变量last中)，遍历它的后缀链接，直到到达初始状态。我们==将所有遍历到的节点都标记为终止节点==**。

这样做我们会==准确地标记字符串s的所有后缀，这些状态都是终止状态==。



### 2.算法正确性证明

#### (1)连续转移和不连续转移

若一个转移$(p,q)$满足$len(p)+1=len(q)$，则我们称这个转移是**连续的**，否则，即当$len(p)+1<len(q)$时，这个转移称为**不连续的**。

连续的、不连续的转移是算法的不同情况。

**连续的转移是固定的，我们不会再改变了，即使是插入新的字符连续的转移也不会改变**。

与此相反，**当向字符串中插入一个新的字符时，不连续的转移可能会改变**(转移边的端点可能会改变)。

#### (2)新节点、字符、等价类

算法从创建新状态`cur`开始，对应于整个字符串`s+c`，我们**创建一个新的状态节点，与此同时我们也创建了一个新的字符和一个新的等价类。**

+ 在创建一个新的状态之后，我们会从对应整个字符串s的状态通过后缀链接进行遍历。**对于对应整个字符串s通过后缀链接进行遍历遇到每一个状态，我们尝试添加一个通过字符c到新状态`cur`的转移。**然而我们只能添加与原有转移不冲突的转移。因此我们只要找到已存在的c的转移，我们就必须停止。

+ 最简单的情况是我们**到达了虚拟状态-1，这意味着我们为所有s的后缀添加了c的转移。这也意味着，==字符c从未在字符串s中出现过==。**因此`cur`的后缀连接为状态0。

+ 第二种情况下，我们==找到了现有的转移$(p,q)$==。这意味着我们**尝试向自动机内添加一个已经存在的字符串$x+c$ (其中$x$作为$s$的一个后缀，且字符串$x+c$已经作为$s$的一个字串出现过了)**，接下来就不需要继续遍历后缀链接了。

  现在，需要明确从状态`cur`出发的后缀链接应该连接到哪个状态。我们要把后缀链接连接到一个状态上，且其中最长的一个字符串恰好是$x+c$，即这个状态的$len$应该是$len(p)+1$，下面就需要分$len(q)=len(p)+1$的连续转移和$len(q)>len(p)+1$的不连续情况考虑。

  + 如果转移$(p,q)$是连续的，那么$len(q)=len(p)+1$。在这种情况下我们只需要将`cur`的后缀链接指向状态q。
  + 否则转移是不连续的，即$len(q)>len(p)+1$，这意味着**状态q不只对应于长度为$len(p)+1$的后缀$s+c$，还对应于$s$的更长子串**。除了**将状态$q$拆成两个子状态以外我们别无他法，所以，第一个子状态的长度就是$len(p)+1$。**
    + 对于状态q的拆分，我们复制状态q，产生一个状态clone，我们将$len(clone)$赋值为$len(p)+1$。由于我们不想改变遍历到q的路径，我们**将q的所有转移复制到clone。我们也将从clone出发的后缀链接赋值为为q的后缀链接的目标，并且设置q的后缀链接为clone，在拆开状态之后，我们将从`cur`出发的后缀链接设置为clone。**
    + 拆分了q之后，我们需要**将一些到q的转移重定向到clone**，只重定向相当于所有字符串$w+c$  (其中$w$是$p$的最长字符串) 的后缀就够了。即，我**们需要继续沿着后缀链接遍历，从结点p直到虚拟状态-1或者是转移到不是状态q的一个转移。**

