# 后缀自动机(SAM)

约定$\sum$为字符集，$|\sum|$为字符集大小，对于一个字符串$s$，记$|s|$为其长度。

## 一、后缀自动机概述

**后缀自动机SAM(suffix automation)**可以理解为给定字符串的**==所有子串的压缩形式==**。SAM将所有的这些信息以高度压缩的形式储存，对于一个长度为n的字符串，其空间复杂度为$O(n)$，此外，构造SAM的时间复杂度仅为$O(n)$。准确地说，**一个SAM最多有$2n-1$个节点和$3n-4$条转移边。**

可以通过SAM在线性时间内解决的字符串问题：

+ **在一个字符串中搜索一个字符串的所有出现位置。**
+ **计算给定的字符串中有多少个不同的子串。**



## 二、后缀自动机SAM的定义

**字符串s的SAM是一个==接受s的所有后缀的最小DFA==(确定性有限状态自动机)。**

换句话说：

+ SAM是一张有向无环图。**结点被称作状态，边被称作状态间的转移。**
+ 图存在一个**源点$t_0$，称作初始状态**，其他各结点均可从$t_0$出发到达。
+ **每个转移都标有一些字母**，从一个结点出发的所有转移均不同。
+ **存在一个或多个终止状态**。如果我们从初始状态$t_0$出发，最终转移到了一个终止状态，则**路径上的所有转移连接起来一定是字符串s的一个后缀**。s的**==每一个后缀均可用一条从$t_0$到某个终止状态的路径构成。==**
+ 在所有满足上述条件的自动机中，SAM的节点数是最少的。



### 1.子串的性质

SAM最简单，也最重要的性质是，它**包含关于字符串s的所有子串的信息**，**任意==从初始状态$t_0$开始的路径==，如果我们==将转移路径上的标号写下来，都会形成$s$的一个子串==**。反之每个s的子串对应从$t_0$开始的某条路径。

为了简化表达，我们称**子串对应一条路径(从$t_0$开始，由一些标号构成这个子串)**。反过来，我们说**任意一条路径对应它的标号构成的字符串。**

**==到达某个状态的路径可能不止一条==，因此，我们说==一个状态对应一些字符串的集合==，这个集合的元素对应这些路径。**



## 三、构造SAM的一些概念

构造SAM过程中的一些重要概念：转移，后缀链接，结束位置(状态、等价类)。

### 1.结束位置`endpos`

我们在实际编程时是不会记录`endpos`的，但是`endpos`的概念有助于我们理解算法流程，因为**部分状态对应的`endpos`是会随着新字符的加入而发生改变的。**



> 我们在每次在字符串末尾增加新的字符时，必定会增加一个`endpos`为最后一个字符位置的状态，**至少新的字符串本身就对应一个`endpos={last_ind}`的状态，因为这个字符串之前从来没有出现过**，而这个状态就是新的后缀的状态，**==通过建立新的后缀指针link，可以在别的状态中增加这个`endpos`中的内容。==**
>
> **根据之前的后缀状态last遍历其后缀指针时，实际上就是==建立新的转移，更新部分`endpos`中的内容(有时会根据子串长度对状态进行拆分)。==**
>
> **因此，==`endpos`是和子串的长度密切相关的。==**



考虑字符串$s$的任意非空子串$t$，我们**记$endpos(t)$为在字符串$s$中$t$的==所有结束位置==**(假设对字符串中**字符的编号从零开始**)。

**两个子串$t_1$和$t_2$的$endpos$集合可能相等：**$endpos(t_1)=endpos(t_2)$。**==这样字符串$s$的所有非空子串都可以根据它们的$endpos$集合被分为若干等价类==**。

显然，**SAM中的==每一个状态对应一个或多个$endpos$相同的子串==。**换句话说，**$SAM$中的==状态数等于所有子串的等价类的个数==**，再加上初始状态。SAM的状态个数等价于$endpos$相同的一个或多个子串所组成的集合个数+1。 

关于`endpos`的值的一些重要结论：

1. **引理1**：字符串s的两个非空子串$u$和$w$(假设$|u|\le|w|$)的`endpos`相同，当且仅当**字符串$u$在$s$中的每次出现，都是以$w$后缀的形式存在的。**

   > 这个引理的证明是显然的。

2. **引理2**：考虑两个非空子串$u$和$w$(假设$|u|\le|w|$)。那么要么$endpos(u)\cap endpos(w)=\empty$，要么$endpos(w)\subseteq endpos(u)$，取决于$u$是否为$w$的一个后缀：
   $$
   \left\{
   \begin{array}{**lr**}
   endpos(w) \subseteq endpos(u) \qquad if\;u\;is\;a\;suffix\;of\;w\\
   endpos(w) \cap endpos(u) = \emptyset \qquad otherwise
   \end{array}
   \right.
   $$

   > **证明：**
   >
   > 如果集合$endpos(u)$与$endpos(w)$有至少一个公共元素，那么可以得出**字符串$u$与$w$在相同位置结束，$u$是$w$的一个后缀。**所以周期每次$w$出现的位置，子串$u$也会出现。但是子串$u$出现的地方$w$不一定出现，所以$endpos(w) \subseteq endpos(u)$。

3. **引理3**：考虑一个$endpos$等价类，将类中的所有子串按照长度非递增的顺序排列。每个子串都不会比它前一个子串长，于此同时每个子串也是它前一个子串的后缀。即，**对于同一等价类的任意两字串，较短者为较长者的后缀**，且该**等价类中的子串长度恰好覆盖整个区间$[x,y]$。**

   > **证明：**
   >
   > 如果$endpos$等价类中只包含一个子串，引理显然成立。
   >
   > 下面讨论子串元素个数大于1的等价类。
   >
   > 由引理1,`endpos`相同的两个非空子串，即根据$endpos$等价的字符串中，较短者总是较长者的真后缀，**因此，等价类中没有等长的字符串。**
   >
   > 记$w$为等价类中最长的字符串、$u$为等价类中最短的字符串。由引理1,字符串$u$是字符串$w$的真后缀。现在考虑长度在区间$[|u|,|w|]$中的$w$的任意后缀，显然，这个后缀也在同一等价类中，因为这个后缀只能在字符串s中以$w$的一个后缀的形式存在(也因为较短的后缀$u$在$s$中只以$w$的后缀的形式存在)。




### 2.后缀链接link

考虑SAM中某个不是$t_0$的状态$v$。我们已经知道，**状态$v$对应于具有相同`endpos`的等价类。**定义$w$是这些字符串中最长的一个，则等价类中其他的字符串都是$w$的后缀。

此外，字符串$w$的按长度降序排列的前几个后缀包含在这个等价类，**其余后缀(至少有一个空后缀)在其他等价类中**，记$t$为不在$w$等价类中的最长后缀，之后**将状态$v$的后缀链接link连接到$t$对应的状态上。**

换句话说，**一个后缀链接$link(v)$连接到对应于$w$的具有不同$endpos$的最长后缀的等价类的状态。**

我们假设初始状态$t_0$对应于它自己这个等价类(只包含一个空字符串)。为了方便，我们规定$endpos(t_0)=\{-1,0,...,|S|-1\}$。

1. **引理4**：所有后缀链接构成一棵根节点为$t_0$的树。

   > **证明：**
   >
   > 考虑任意不是$t_0$的状态$v$，**后缀链接$link(v)$连接到的状态对应于严格更短的字符串**。因此，**沿后缀链接移动，我们总是能到达对应空串的初始状态$t_0$**。

2. **引理5**：通过`endpos`集合构造的树**(每个子节点的subset都包含在父节点的subset中**)与通过后缀链接link构造的树相同。

   > **证明**：
   >
   > 根据引理二，任意一个SAM的`endpos`集合形成了一棵树(**因为两个集合要么完全没有交集要么其中一个是另一个的子集**)。
   >
   > 考虑任意不是$t_0$的状态$v$以及后缀链接$link(v)$，由后缀链接和引理2,我们可以得到:
   > $$
   > endpos(v)\subseteq endpos(link(v))
   > $$

**==后缀链接构成的树本质上是$endpos$集合构成的一棵树。==**



### 3.结论

+ s的**子串可以根据它们的结束位置`endpos`话分成多个等价类。**

+ SAM由初**始状态$t_0$和与每一个`endpos`等价类对应的每个状态组成。**

+ 对于**每一个状态$v$，一个或多个子串与之匹配**。我们记$longest(v)$为其中最长的一个字符串，记$len(v)$为其长度。类似地，记$shortest(v)$为最短的子串，它的长度为$minlen(v)$。那么**对应这个状态的所有字符串都是字符串$longest(v)$的不同的后缀，且所有字符串的长度恰好覆盖区间$[minlen(v),len(v)]$中的每一个整数。**

+ 对于任意不是$t_0$的状态$v$，定义**后缀链接为连接到对应字符串$longest(v)$的长度为$minlen(v)-1$的后缀的一条边**。**从根结点$t_0$出发的后缀链接可以形成一棵树。这棵树也表示`endpos`集合间的包含关系。**

+ 对于$t_0$以外的状态$v$，可用后缀链接$link(v)$表达$minlen(v)$：
  $$
  minlen(v)=len(link(v))+1
  $$

+ 如果我们**从任意状态$v_0$开始顺着后缀链接遍历，总会到达初始状态$t_0$。**这种情况下我们可以得到一个互不相交的区间$[minlen(v_i),len(v_i)]$的序列，且它们的并集形成了连续的区间$[0,len(v_0)]$。



## 四、线性时间构造SAM的算法

**构造SAM的算法是在线算法**，我们可以逐个加入字符串中的每个字符，并且在每一步中对应地维护SAM。

**==构造SAM需要注意理解的概念：转移，后缀链接，`len(endpos)`==**。

为了保证线性的空间复杂度，我们将**只保存`len`和`link`的值和每个状态的转移列表**，我们不会标记终止状态。



### 1.构造SAM的算法步骤

一开始SAM只包含一个状态$t_0$，编号为0(其他状态的编号为1，2，...)。为了方便，**对于状态$t_0$我们指定$len=0,link=-1$(-1表示虚拟状态)。**

那么，任务转化为实现给当前字符串添加一个字符c的过程。算法流程如下：

+ 令**$last$为添加字符c之前，整个字符串对应的状态**(一开始我们设$last=0$，算法的最后一步更新$last$)。

  > **==增加一个新字符，相当于增加了一系列后缀$x+c$==，**即在之前后缀的基础上+新字符c，所以需要保存前一个后缀的状态last。

+ **创建一个新的状态$cur$，并将$len(cur)$赋值为$len(last)+1$，**在这时$link(cur)$的值未知。

  > 增加了一个字母，因为`endpos`可以往后移动1位，新的子串的长度确实会更长，那么就将其赋值为$len(last)+1$。

+ 从状态$last$开始，按照以下流程进行：**遍历后缀链接，如果还没有到字符c的转移，我们就添加一个到状态$cur$的转移(==这一步是为了增加新的字符串后缀，使子串查询成为可能。==)。如果在某个点已经存在到字符c的转移，我们就停下来，并将这个状态标记为p。**

  + 如果没有找到这样的状态p，我们就到达了虚拟状态-1,我们将$link(cur)$赋值为0并退出。

  + 假设现在我们找到了一个状态p，其可以通过字符c转移，我们将转移到的状态标记为q。

    现在我们分类讨论两种情况：要么$len(p)+1=len(q)$，要么不是。

    + 如果$len(p)+1=len(q)$，我们只要将$link(cur)$赋值为q并退出。

    + 否则我们需要 **复制** 状态q，**创建一个新的状态clone，复制q的除了$len$的值以外的所有信息(后缀链接和转移)**。我们**将$len(clone)$赋值为$len(p)+1$。**

      复制之后，我们将后缀链接从`cur`指向`clone`，也从`q`指向`clone`。

      最终我们需要**使用后缀链接从状态p继续沿着后缀链接走，只要存在一条通过p到状态q的转移，就将该转移重定向到状态clone。**

  + 以上三种情况，在完成这个过程之后，我们**将last的值更新为状态`cur`。**

如果我们还想知道哪些状态是**终止状态**而哪些不是，我们可以**在为字符串s构造完整的SAM后找到所有的终止状态**。为此，我们**从对应整个字符串的状态(存储在变量last中)，遍历它的后缀链接，直到到达初始状态。我们==将所有遍历到的节点都标记为终止节点==**。

这样做我们会==准确地标记字符串s的所有后缀，这些状态都是终止状态==。



### 2.算法正确性证明

#### (1)连续转移和不连续转移

若一个转移$(p,q)$满足$len(p)+1=len(q)$，则我们称这个转移是**连续的**，否则，即当$len(p)+1<len(q)$时，这个转移称为**不连续的**。

连续的、不连续的转移是算法的不同情况。

**连续的转移是固定的，我们不会再改变了，即使是插入新的字符连续的转移也不会改变**。

与此相反，**当向字符串中插入一个新的字符时，不连续的转移可能会改变**(转移边的端点可能会改变)。

#### (2)新节点、字符、等价类

算法从创建新状态`cur`开始，对应于整个字符串`s+c`，我们**创建一个新的状态节点，与此同时我们也创建了一个新的字符和一个新的等价类。**

+ 在创建一个新的状态之后，我们会从对应整个字符串s的状态通过后缀链接进行遍历。**对于对应整个字符串s通过后缀链接进行遍历遇到每一个状态，我们尝试添加一个通过字符c到新状态`cur`的转移。**然而我们只能添加与原有转移不冲突的转移。因此我们只要找到已存在的c的转移，我们就必须停止。

+ 最简单的情况是我们**到达了虚拟状态-1，这意味着我们为所有s的后缀添加了c的转移。这也意味着，==字符c从未在字符串s中出现过==。**因此`cur`的后缀连接为状态0。

+ 第二种情况下，我们==找到了现有的转移$(p,q)$==。这意味着我们**尝试向自动机内添加一个已经存在的字符串$x+c$ (其中$x$作为$s$的一个后缀，且字符串$x+c$已经作为$s$的一个字串出现过了)**，接下来就不需要继续遍历后缀链接了。

  现在，需要明确从状态`cur`出发的后缀链接应该连接到哪个状态。我们要把后缀链接连接到一个状态上，且其中最长的一个字符串恰好是$x+c$，即这个状态的$len$应该是$len(p)+1$，下面就需要分$len(q)=len(p)+1$的连续转移和$len(q)>len(p)+1$的不连续情况考虑。

  + 如果转移$(p,q)$是连续的，那么$len(q)=len(p)+1$。在这种情况下我们只需要将`cur`的后缀链接指向状态q。
  + 否则转移是不连续的，即$len(q)>len(p)+1$，这意味着**状态q不只对应于长度为$len(p)+1$的后缀$s+c$，还对应于$s$的更长子串**。除了**将状态$q$拆成两个子状态以外我们别无他法，所以，第一个子状态的长度就是$len(p)+1$。**
    + 对于状态q的拆分，我们复制状态q，产生一个状态clone，我们将$len(clone)$赋值为$len(p)+1$。由于我们不想改变遍历到q的路径，我们**将q的所有转移复制到clone。我们也将从clone出发的后缀链接赋值为为q的后缀链接的目标，并且设置q的后缀链接为clone，在拆开状态之后，我们将从`cur`出发的后缀链接设置为clone。**
    + 拆分了q之后，我们需要**将一些到q的转移重定向到clone**，只重定向相当于所有字符串$w+c$  (其中$w$是$p$的最长字符串) 的后缀就够了。即，我**们需要继续沿着后缀链接遍历，从结点p直到虚拟状态-1或者是转移到不是状态q的一个转移。**



### 3.对空间、操作次数为线性的证明

首先，假设**字符集大小为常数**，如果字符集大小不是常数，SAM的时间复杂度就不是线性的。使用map存储转移，记字符集为$\sum$，字符集大小为$|\sum|$，则算法的渐进时间复杂度为$O(n\log|\sum|)$，空间复杂度为$O(n)$。

因为假设字符集大小是常数，即每次对一个字符搜索转移、添加转移、查找下一个转移，这些操作的时间复杂度都为$O(1)$。

由于算法中每次增加一个字符，最多会增加两个状态，所以最多会有$2n-1$个状态，即空间复杂度为$O(n)$。

但是考虑算法的各个部分，有三处时间复杂度不明显是线性的：

+ 第一处：遍历所有状态last的后缀链接，添加字符c的转移。(总复杂度是线性的，因为单词操作只为自动机添加了一个新转移)
+ 第二处：当状态被复制到一个新的状态clone的复制转移过程。(总复杂度是线性的，因为字符集大小是常数)
+ 第三处：修改指向q的转移，将它们重定向到clone的过程。

对于第三处的估计总复杂度，记$v=longest(p)$，这是一个字符串s的后缀，因为字符串s的位置每次迭代都单调上升，每次迭代长度都递减。如果在循环的第一次迭代之前，相应的字符串v在距离last的深度为k($k\ge2$)的位置上(深度记为后缀链接的数量)，那么在最后一次迭代之后，字符串$v+c$将会成为路径上第二个从`cur`出发的后缀链接(它将会成为新的last值)。

**循环中的每次迭代都会使作为当前字符串的后缀的字符串$longest(link(link(last)))$的位置单调递增，因此这个循环最多不会执行超过n次迭代。**



## 五、代码实现

```c++
#include<iostream>
#include<string>
#include<vector>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<algorithm>
using namespace std;

#define MAX_N 100010

struct State {
    int len, link;
    map<char, int> next;
};

// SAM的状态数组
State st[MAX_N << 1 + 10];
// last是最近后缀状态，sz是所有状态个数
int last, sz;
string text, pattern;

// 后缀自动机初始化
void sam_init() {
    // st[0]即t0初始状态，len = 0, 后缀链接link = -1
    st[0].len = 0;
    st[0].link = -1;
    last = sz = 0;
    sz++;
}

void sam_add(char c) {
    // cur新增状态、字符
    int cur = sz++;
    // cur的len为last的len加1
    st[cur].len = st[last].len + 1;
    // 处理新后缀字符串
    int p = last;
    // 可以注意一下map的成员函数count()的用法
    // 遍历后缀链接，增加新的链接，即增加新的后缀字符串
    while (p != -1 && !st[p].next.count(c)) {
        st[p].next[c] = cur;
        p = st[p].link;
    }
    if (p == -1) {
        // 所有后缀都没有出现过的情况，st[cur].link = 0
        st[cur].link = 0;
    } else {
        // 找到了出现过的后缀和转移，分连续转移和非连续的转移来处理
        int q = st[p].next[c];
        if (st[p].len + 1 == st[q].len) {
            // 连续的转移，st[cur].link = q
            st[cur].link = q;
        } else {
            // 非连续的转移，需要新建一个状态clone来构造连续的转移
            int clone = sz++;
            st[clone].len = st[p].len + 1;
            st[clone].link = st[q].link;
            st[clone].next = st[q].next;
            // 将接下来后缀链接里会通过c转移到q的重定向到clone
            while (p != -1 && st[p].next[c] == q) {
                st[p].next[c] = clone;
                p = st[p].link;
            }
            // 完善后缀链接
            st[cur].link = st[q].link = clone;
        }
    }
    // 更新后缀下标
    last = cur;
}

bool handle() {
    int p = 0;
    for (auto &x : pattern) {
        if (!st[p].next.count(x)) return false;
        p = st[p].next[x];
    }
    return true;
}

int main() {
    sam_init();
    cin >> text;
    for (auto &x : text) sam_add(x);
    while (cin >> pattern) {
        cout << pattern << " " << (handle() ? "Match" : "Miss") << endl;
    }
    return 0;
}
```



## 六、后缀自动机的应用场景

### 1.检查字符串是否出现

>  给一个文本传T和多个模式串P，我们检查字符串P是否作为T的一个子串出现。

我们在$O(|T|)$时间内对文本串T构造后缀自动机。为了检查模式串P是否在T中出现，我们从 $t_0$开始根据P的字符进行转移，如果在某个点无法转移下去，则模式串P不是T的一个子串，如果能够处理完整的字符串P，那么模式串在T中出现过。

### 2.求不同子串个数

> 给一个字符串S，计算不同子串的个数

对字符串S构造后缀自动机。每个S的子串都相当于自动机中的一些路径。因此**不同子串的个数等于自动机中以$t_0$为起点的不同路径的条数。**

由于**SAM是有向无环图，不同路径的条数可以通过动态规划(或者递归)计算**。即，令$d_v$为从状态$v$开始的路径数量(包括长度为0的路径)，则我们有如下递推方程：
$$
d_v=1+\sum_{w:(v,w,c)\in DAWG}d_w
$$
即，$d_v$可以表示为所有$v$的转移的末端的和。

因此，不同子串的个数为$d_{t_0}-1$，因为要去掉空字符串。总的时间复杂度为$O(|S|)$。



另一种方法是利用SAM的树形结构，**每个结点对应的子串数量是$len(i)-len(link(i))$，对自动机所有节点求和即可。**

### 3.求所有不同子串的总长度

> 给定一个字符串S，计算所有不同字串的总长度

这题的做法与上一题类似，只是我们需要考虑分两部分进行动态规划：不同子串的数量$d_v$和它们的总长度$ans_v$。

递推方程如下：
$$
d_v=1+\sum_{w:(v,w,c)\in DAWG}d_w\\
ans_v=\sum_{w:(v,w,c) \in DAWG}{d_w+ans_w}
$$


同样，我们可以利用后缀自动机的树形结构，每个节点对应的所有后缀长度是$\frac{len(i)*(len(i)+1)}{2}$，减去其$link$节点对应的值就是该节点的净贡献，最自动机的所有节点求和即可。

### 4.字典序第k大子串

> 给定一个字符串S。多组询问，每组询问给定一个数$K_i$，查询S的所有子串中字典序第$K_i$大的子串。

字典序第K大的子串对应于SAM中字典序第K大的路径，因此在计算每个状态的路径数后，我们可以很容易地从SAM的根开始找到第k大的路径。

预处理的时间复杂度是$O(|S|)$，单词查询的时间复杂度是$O(|ans|*|\sum|)$，其中$ans$为查询的答案，$|\sum|$是字符集的大小。

**由于这道题涉及到字典序，所以使用后缀数组做最方便。**

### 5.最小循环移位

> 给定一个字符串$|S|$，找出字典序最小的循环移位。

**==字符串$S+S$包含字符串$S$的所有循环移位作为子串==。**因此，问题简化为**在$S+S$对应的后缀自动机上寻找最小的长度为$|S|$的路径。**

使用贪心思想，**从初始状态开始，贪心地访问最小的字符即可，如果有一个路径的长度达到$|S|$，则是字典序最小的循环移位。**

总的时间复杂度是$O(|S|)$。

### 6.出现次数

> 对于一个给定的文本串$T$，有多组询问，每组询问给一个模式串$P$，回答模式串$P$在字符串$T$中作为子串出现了多少次。

利用后缀自动机的树形结构，进行dfs即可预处理每个节点的终点集合的大小。**在自动机上查找模式串$P$对应的节点，如果存在，则答案就是终点集合的大小;如果不存在，则答案为0。**

> 因为SAM中的每个节点都代表着`endpos`相同的等价类子串，又因为在建立link后缀链接的时候，我们之将一个状态的位置添加到一个其他状态上，所以**一个状态不可能以两种不同的方式将其位置重复地指向另一个状态。**

预处理时间复杂度为$O(|T|)$，单词查询的时间复杂度为$O(|P|)$。

### 7.第一次出现的位置

> 给定一个文本串$T$，多组查询。每次查询字符串$P$在字符串$T$中第一次出现的位置($P $的开头位置)。

我们基本上不会维护`endpos`集合，因为维护的代价太大，但是我们可以**在构造后缀自动机的时候，对SAM中所有状态预处理位置`firstpos`。**即，对每个状态$v$我们想要找到第一次出现这个状态的末端的位置`firstpos[v]`，换句话说，我们希望先找到每个集合`endpos`中的最小元素。

**为了维护`firstpos`这些位置，当我们创建新状态`cur`时，我们令：**
$$
firstpos(cur)=len(pos)-1
$$
**当我们将节点q复制到clone时**，我们令：
$$
firstpos(clone)=firstpos(q)
$$
那么**查询的答案就是$firstpos(t)-|P|+1$，其中t为对应字符串$P$的状态，单次查询只需要$O(|P|)$的时间。**

### 8.所有出现的位置

> 给定一个文本串，多组查询。每次查询字符串$P$在字符串$T$中模式串出现的所有位置。

还是利用后缀自动机的树形结构，遍历子树，一旦发现终点节点就输出。我们还是需要为所有状态计算位置$firstpos$，**如果$t$为对应于模式串$T$的状态，显然$firstpos(t)$为答案的一部分。**此外，我们还需要**找到==所有可以通过后缀链接到达状态t的状态==。**

为了解决这个问题，我们需要**为每一个状态保存一个指向它的后缀引用列表，查询的答案就包含在对于每个我们能从状态t只使用后缀引用进行DFS或者BFS的所有状态的`firstpos`值。**

这种变通方案的时间复杂度是$O(answer(P))$，因为我们不会重复访问一个状态(因为对于仅有一个后缀链接指向一个状态，所以**不存在两条不同的路径指向同一状态**)。

我们只需要**考虑两个可能有相同$endpos$值的不同状态，如果一个状态是由另一个复制过来的，则这种情况会发生**，然而，这并不会对复杂度分析造成影响，因为**每个状态至多被复制一次。**

如果我们不从被复制的节点输出位置，我们也可以去除重复的位置。事实上对于==一个状态，如果经过被复制状态可以到达，则经过原状态也可以到达==。因此，如果我们**给每个状态记`is_clone`来代表这个状态是不是被复制出来的，我们就可以简单地==忽略掉被复制的状态==，只输出其他所有状态的`firstpos`值。**

大致的实现如下：

```c++
struct state {
  bool is_clone;
  int first_pos;
  std::vector<int> inv_link;
  // some other variables
};

// 在构造 SAM 后，构造后缀引用
for (int v = 1; v < sz; v++) st[st[v].link].inv_link.push_back(v);

// 输出所有出现位置
void output_all_occurrences(int v, int P_length) {
    // 如果不是复制的状态，则输出，否则不输出
  if (!st[v].is_clone) cout << st[v].first_pos - P_length + 1 << endl;
    // 反向遍历后缀引用
  for (int u : st[v].inv_link) output_all_occurrences(u, P_length);
}
```

### 9.最短的没有出现的字符串(==没看懂==)

> 给定一个字符串S和一个特定的字符集，我们要找一个长度最短的没有在S中出现过的字符串。

**我们==在字符串S的后缀自动机上做动态规划==。**

令$d_v$为节点v的答案，即，我们已经处理完了子串的一部分，**当前在状态v，想找到不连续的转移需要添加的最小字符数量。**如果不存在使用字符集中至少一个字符的转移，则$d_v=1$。否则添加一个字符是不够的。我们需要求出所有转移中的最小值：
$$
d_v=1+\min_{w:(v,w,c)\in SAM}d_w
$$
最终答案就是$d_{t_0}$，字符串可以通过计算过的数组d逆推回去。

### 10.两个字符串的最长公共子串

> 给定两个字符串S和T，求出最长公共子串，公共子串定义为在S和T中都作为子串出现过的字符串X。

我们对字符串S构造后缀自动机。

我们现在来处理字符串T，**对于每一个前缀，都在S中寻找这个前缀的最长后缀**。换句话说，对于每个字符串T中的位置，我们想要找到这个位置结束的S和T的最长公共子串的长度。显然问题的答案就是所有$l$的最大值。

我们使用两个变量，**当前状态$v$和当前长度$l$。**这两个变量描述当前匹配的部分：**它的长度和它们对应的状态。**

一开始$v=t_0$且$l=0$，即，匹配为空串。

添加一个字符$T_i$，并为其重新计算答案：

+ 如果**存在一个从$v$到字符$T_i$的转移，我们只需要转移并让$l$自增1**。

+ 如果**不存在这样的转移，我们需要缩短当前匹配的部分，这意味着我们需要按照后缀链接进行转移：**
  $$
  v=link(v)
  $$
  同时，需要**缩短当前长度，显然我们需要将$l$赋值为$len(v)$，**因为经过这个后缀链接我们到达的状态所对应的最长字符串是一个子串。

+ 如果仍然没有使用这一字符的转移，我们继续重复经过后缀链接并减小$l$，**直到我们找到一个转移或到达虚拟状态-1(这意味着字符$T_i$根本没有在S中出现过，所以我们设置$v=l=0$)。**

这一部分的时间复杂度为$O(|T|)$，因为每次移动我们要么可以使$l$增加1,要么可以在后缀链接间移动几次，每次都减小$l$的值。

> 这里的失配转移，实际上还是通过后缀，每次减小后缀长度，在更多位置进行匹配。

代码实现：

 ```c++
string lcs(string &str_1, string &str_2) { 
    sam_init();
    for (int i = 0; str_1[i]; i++) sam_add(str_1[i]);
    int v = 0, l = 0, best_len = 0, best_pos = 0;
    for (int i = 0; str_2[i]; i++) {
        while (v && !st[v].next.count(str_2[i])) {
            v = st[v].link;
            l = st[v].len;
        }
        if (st[v].next.count(str_2[i])) {
            v = st[v].next[str_2[i]];
            l++;
        }
        if (l > best_len) {
            best_pos = l;
            best_len = i;
        }
    }
    return str_1.substr(best_pos - best_len + 1, best_len);
}
 ```

### 11.多个字符串间的最长公共子串

> 给定k个字符串$S_i$，我们需要找到它们的最长公共子串，即作为子串出现在每个字符串中的字符串X。

我们将所有的子串连接成一个较长的字符串$T$，以特殊字符$D_i$分开每个字符串(一个字符对应一个字符串)：
$$
T=S_1+D_1+S_2+D_2+...+S_k+D_k
$$
然后对字符串$T$构造后缀自动机。

现在我们需要在自动机中找到存在于所有字符串$S_i$中的一个字符串，这可以通过使用添加的特殊字符完成。注意如果$S_j$包含了一个子串，则SAM中存在一条从包含$D_j$的子串而不包含以其他字符$D_1,...D_{j-1},D_{j+1},...,D_k$开始的路径。

因此我们需要计算可达性，即对于自动机中的每个状态和每个字符$D_i$，是否存在这样的一条路径，**这可以通过DFS,BFS或者动态规划求解。**之后，问题的**答案就是状态$v$的字符串$longest(v)$中存在所有特殊字符的路径。**

**==多个字符串间的最长公共子串还是适合使用广义后缀自动机求解。==**