# 最小表示法

## 一、最小表示法的引入

**一个长度为n的首尾相连的字符串可以有n种表示法**，例如串 abcd 还可以表示bcda，cdab，dabc当我们面临这样的字符串的时候，我们很难统计相同字符串的个数。因此我们**引入一种字符串的最小表示法来使这些串变得相同。**

> 即，最小表示法解决的是首位相连的字符串的表示问题。



## 二、字符串的最小表示

### 1.循环同构

当字符串S中可以选定一个位置i满足：
$$
S[i...n]+S[1...i-1]=T
$$
则S与T循环同构。

### 2.最小表示

**字符串S的最小表示为与S循环同构的所有字符串中字典序最小的字符串**。

> 实际上字符串的最小表示法可以用后缀数组求解，即对$S+S$求后缀数组，采用$SA-IS$或者$DC3$算法可以在$O(N)$时间、空间复杂度解决问题。



## 三、暴力解法

我们**每次比较i和j开始的循环同构，把当前比较到的位置记作k，==每次遇到不一样的字符时便把大的跳过==，最后剩下的就是最优解**。

```c++
int k = 0, i = 0, j = 1;
while (k < n && i < n && j < n) {
  if (sec[(i + k) % n] == sec[(j + k) % n]) {
    ++k;
  } else {
    if (sec[(i + k) % n] > sec[(j + k) % n])
      ++i;
    else
      ++j;
    k = 0;
    // 如果i和j相等的话，就让其中一个+1，保证比较的两个字符串不同
    if (i == j) i++;
  }
}
// 这。。。应该是选择字典序小的。。。
i = min(i, j);
```

随机数据下表现良好，但是可以构造特殊数据卡掉。当字符串中出现多个连续重复子串时，次算法的时间复杂度退化为$O(n^2)$。



## 四、最小表示法

### 1.算法原理

考虑对于一对字符串A，B，它们在原字符串S中的起始位置分别是i，j，且它们的前k个字符均相同，即:
$$
S[i...i+k-1]=S[j...j+k-1]
$$
不妨先考虑$S[i+k]>S[j+k]$的情况，可以发现其实**位置下标$l$满足$i\le l \le i+k$的字符串均不能成为答案，这是显然的，因为==对$i \le l \le i+k$中的l，都会有相应的$j\le L \le j+k$比其更优==，所以可以只变动出现分歧时值较大的下标**。因为对于任意一个字符串$S_{i+p}$(表示以$i+p$为起始位置的字符串)一定存在字符串$S_{j+p}$比它更优。

所以，我们比较时可以跳过下标$l\in[i,i+k]$，直接比较$S_{i+k+1}$。

### 2.算法流程

1. 初始化指针i为0,j为1,匹配长读k为0。
2. 比较第k位的大小，根据比较结果跳转相应指针。若跳转后两个指针相同，则随意选一个加一以保证比较的两个字符串不同。
3. 重复上述过程，直到比较结束。
4. 答案为i，j中较小的一个

### 3.代码

```c++
int k = 0, i = 0, j = 1;
while (k < n && i < n && j < n) {
  if (sec[(i + k) % n] == sec[(j + k) % n]) {
    k++;
  } else {
    // 大的下标进行跳转
    sec[(i + k) % n] > sec[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
    // 如果i == j，这里就选择让i++，其实j++也是可以的。
    if (i == j) i++;
    k = 0;
  }
}
i = min(i, j);
```

