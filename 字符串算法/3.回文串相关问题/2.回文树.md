# 回文树

## 一、回文树的概念

回文树(Palindromic Tree)，也被称为**回文自动机**，是一种可以**存储一个串中所有回文子串的高效数据结构。**



## 二、回文树的结构

与其他自动机类似，回文树也是由转移边和后缀链接(fail指针)组成，每个节点都可以代表一个回文子串。

因为回文串长度分为奇数和偶数，我们可以**建立两棵树，一棵树中的节点对应的回文子串长度均为奇数，另一棵树中的节点对应的回文字串长读均为偶数。**

和其他自动机一样，**一个节点的fail指针指向的是这个节点所代表的回文串的最长回文后缀所对应的节点**，但是**转移边表示在原节点代表的回文串前后各增加一个相同的字符**(因为要保证是回文串)。

我们还需要**在每个节点上维护此节点对应回文子串的长度$len$，**这个信息保证了我们可以轻松地构造出回文树。



## 三、回文树的建造

**回文树有两个初始状态，分别代表长度为-1，0的回文串，我们可以称它们为奇根，偶根。**它们不表示任何实际的字符串，仅作为初始状态存在，这和其他自动机的根节点是异曲同工的。

偶根的fail指针指向奇根，而我们并不关心奇根的fail指针，因为奇根不可能失配(奇根转移出的下一个状态长度是1,即单个字符，一定是回文串)。

**类似后缀自动机，我们增量构造回文树。**

考虑构造完前$p-1$个字符的回文树后，向自动机中添加在原串里位置为p的字符。

我们**==从上一个字符结尾的最长回文子串对应的节点开始，不断沿fail指针走，直到找到一个节点满足$s_p=s_{p-len-1}$==，即满足此节点所对应回文子串的上一个字符与待添加的字符相同。**

![img](./pam2.png)

我们通过**==跳fail指针找到A所对应的节点，然后两边添加X就到了现在的回文串了(`XAX`)==**，很显然，这个节点就是以p结尾的最长回文子串对应的树上节点。(同时，这个时候长度为-1的节点优势就出来了，如果没有X能匹配条件，就是同一个位置$s_p=s_p$，自然就得到了代表字符X的节点。)此时要判断一下：**没有这个节点，就需要新建。**

然后我们还需要**==求出新建的节点的fail指针==，具体方法与上面的过程类似，不断跳转fail指针，从A出发，即可找到`XAX`的最长回文后缀`XBX`，将相应节点设为fail指针所指的对象即可。**

显然，这个节点是不需要新建的，A的前$len_B$位和后$len_B$位相同，都是B，前$len_B$位的两端根据回文串对应关系，都是X，后面被钦定了是X，于是这个节点XBX肯定已经被包含了。

**如果fail没有匹配到，那么将它连向长度为0的那个节点**，显然这是可行的，因为这是所有节点的后缀。



## 四、线性状态数证明

定理：对于一个字符串s，它的本质不同回文子串个数最多只有$|s|$个。

证明：使用数学归纳法。

+ 当$|s|=1$时，$s$只有一个字符，同时也只有一个子串，并且这个字串是回文的，因此结论成立。
+ 当$|s|>1$时，设$t=sc$，其中t表示s最后增加一个字符c后形成的字符串，假设结论对s串成立。考虑以最后一个字符c结尾的回文子串，假设它们的左端点由小到大排序为$l_1,l_2,...,l_k$。由于$t[l_1...|t|]$是回文串，因此对于所有位置$l_1\le p \le |t|$，有$t[p...|t|]=t[l_1...l_1+|t|-p]$，所以，**对于$1<i\le k，t[l_i...|t|]$已经在$t[1...|t|-1]$中出现过**。因此，**==每次增加一个字符，本质不同的回文子串个数最多增加1个。==**

因此回文树状态数是$O(|s|)$的，**对于==每一个状态，它实际只代表一个本质不同的回文子串==，**即**==转移到该节点的状态唯一==**，因此总转移数也是$O(|s|)$的。



## 五、正确性证明

增加当前字符X，由线性状态数的证明，我们只需要找到包含最后一个字符X的最长回文后缀，即`XAX`。之后继续寻找`XAX`的最长回文后缀`XBX`，建立后缀链接。`XBX`对应状态已经在回文树中出现，**包含最后一个字符的回文后缀就是`XAX`，`XBX`本身及其对应状态在fail树上的所有祖先。**

对于s回文数的构造，令$n=|s|$，显然，除了跳fail指针其他操作都是$O(n)$的。

**加入字符时，在上一次的基础上，每次跳fail后对应节点在fail树的深度-1,而连接fail后，仅为深度+1**(但fail为0时，即跳到-1才符合，深度相当于在-1的基础长+2)。

因为只加入n个字符，所以只会加n次深度，最多也只会跳$2n$次fail。

因此，构造$|s|$的回文树的时间复杂度是$O(|s|)$。



## 六、应用

### 1.本质不同回文子串个数

由现行状态数的证明，容易知道**一个串的本质不同回文子串个数等于回文树的状态数(排除奇根和偶根)。**

### 2.回文子串出现次数

建立回文树，使用类似后缀自动机统计出现次数的方法，实际上就是逆fail指针枚举所有状态，统计次数即可。

### 3.最小回文划分

> 给定一个字符串$s(1\le|s|\le10^{5})$，求最小的$k$，使得存在$s_1,s_2,...,s_k$，满足$s_i(1\le i \le k)$均为回文串，且$s_1,s_2,...,s_k$依次连接后得到的字符串等于$s$。

考虑动态规划，记$dp[i]$表示$s$长读为i的前缀的的最小划分数，转移只需要枚举以第i个字符结尾的所有回文串：
$$
dp[i]=1+\min_{s[j+1...i]为回文串}dp[j]
$$
由于一个字符串最多会有$O(n^2)$个回文子串，因此上述算法的时间复杂度为$O(n^2)$，时间复杂度过高，需要进行优化。

下面给出一些引理：

#### (1)引理1

记字符串s长度为i的前缀为$pre(s,i)$，长度为i的后缀为$suf(s,i)$。

**周期**：若$0<p\le|s|，\forall 1\le i \le |s|-p,s[i]=s[i+p]$，就称p为s的周期。

**border**：若$0 \le r < |s|,pre(s,r)=suf(s,r)$，就称$pre(s,r)$是s的border。

周期和border的关系：**t是s的border，当且仅当$|s|-|t|$是s的周期。**

> **证明**：
>
> 因为t是s的border，那么$pre(s,|t|)=suf(s,|t|)$，因此，$\forall 1 \le i \le |t|,s[i]=s[|s|-|t|+i]$，所以$|s|-|t|$就是s的周期。
>
> 若$|s|-|t|$为s周期，则$\forall 1 \le i \le |s|-(|s|-|t|)=|t|，s[i]=s[|s|-|t|+i]$，因此$pre(s,|t|)=suf(s,|t|)$，所以t是s的border。

**引理1**： t是回文串的后缀，**t是s的border当且进当t是回文串**。

> **证明**：
>
> 对于$1\le i \le |t|$，由s和t为回文串，因此有$s[i]=s[|s|-i+1]=s[|s|-|t|+i]$，所以t是s的border。
>
> 对于$1\le i \le |t|$，由于t是s的border，有$s[i]=s[|s|-|t|+i]$，由s是回文串，有$s[i]=s[|s|-i+1]$，因此$s[|s|-i+1]=s[|s|-|t|+i]$，所以t是回文串。

#### (2)引理2

**引理2**： t是s的border($|s|\le 2|t|$)，s是回文串当且仅当t是回文串。

> **证明**：
>
> 若s是回文串，由引理1,t也是回文串。
>
> 若t是回文串，由于t是s的border，因此$\forall 1 \le i \le |t|,s[i]=s[|s|-|t|+i]=s[|s|-i+1]$，因为$|s|\le 2|t|$，因此s也是回文串。

#### (3)引理3

**引理3**： t是回文串s的border，则$|s|-|t|$是s的周期，$|s|-|t|$为s的最小周期，当且仅当t是s的最长回文真后缀。

> 证明：显然。

#### (4)引理4

**引理4**： **x是一个回文串，y是x的最长回文真后缀，z是y的最长回文真后缀。**令$u,v$分别满足$x=uy，y=vz$的字符串，则有如下三条性质：

1. $|u|\ge|v|$。
2. 如果$|u|\gt|v|$，那么$|u|\gt |z|$。
3. 如果$|u|=|v|$，那么$u=v$。

![img](./pam4.png)

> **证明**：
>
> 1. 由引理3的推论，$|u|=|x|-|y|$是x的最小周期，$|v|=|y|-|z|$是y的最小周期。
>
>    使用反证法，假设$|u|\lt |v|$，因为y是x的后缀，所以u既是x的周期，也是y的周期，而$|v|$是y的最小周期，矛盾，所以$|u|\ge|v|$。
>
> 2. 因为y是x的border，所以v是x的前缀，设字符串w，满足$x=vw$，其中$z$是$w$的border。
>
>    使用反证法，假设$|u|\le|z|$，那么$|zu|\le2|z|$，所以由引理2,$w$是回文串，由引理1,w是x的border，又因为$|u|>|v|$，所以$|w|>|y|$，矛盾。所以$|u|>|z|$。
>
> 3. $u,v$都是$x$的前缀，$|u|=|v|$，所以$u=v$。
>
>    ![img](./pam5.png)

####  (5)推论

**推论**： s的所有回文后缀按照长度排序后，可以划分成$log|S|$段等差数列。

> **证明**：
>
> 设s的所有回文后缀长读从小到大排序为$l_1,l_2,...,l_k$。对于任意$2\le i \le k - 1$，若$l_i-l_{i-1}=l_{i+1}-l_i$，则$l_{i-1},l_i,l_{i+1}$构成一个等差数列。否则$l_i-l_{i-1}\neq l_{i+1}-l_i$，由引理4，有$l_{i+1}-l_i > l_i - l_{i-1}$，且$l_{i+1}-l_i>l_{i-1},l_{i+1}>2l_{i-1}$。因此，**若相邻两对回文后缀的长度之差发生变化，那么这个最大长度一定会相当于最小长度翻一倍。显然，长度翻倍最多只会发生$O(\log{|s|})$次，即s的回文后缀长度可以划分成$\log{|s|}$段等差数列。**

回文树上的每个节点u需要多维护两个信息，$diff[u]$和$slink[u]$。$diff[u]$**表示节点$u$和$fail[u]$所代表的回文串的长度差**，即$len[u]-len[fail[u]]$。$slink[u]$**表示$u$一直沿着$fail$向上跳到第一个节点$v$，使得$diff[v]\neq diff[u]$，也就是$u$所在等差数列中长度最小的那个节点。**

根据上面证明的结论，如果使用$slink$指针向上跳的话，每向后添加一个字符，只需要向上跳$O(\log{|s|})$次，因此，可以考虑将一个等差数列表示的所有回文串的$dp$值之和(在原问题中指$\min$)，记录到最长的那一个回文串对应节点上。

$g[v]$表示$v$所在等差数列的dp之和，且v是这个等差数列中长度最长的节点，则$g[v]=\sum_{x,slink[x]=v}dp[i-len[x]]$ ，这里i是枚举到的下标。

下面考虑如何更新g数组和dp数组。以下图为例，假设当前枚举到第i个字符，回文树上对应节点为x。$g[x]$为橙色三个位置的dp值之和(最短的回文串$slink[x]$算在下一个等差数列中)。$fail[x]$上一次出现的位置是$i-diff[x]$(在$i-diff[x]$处结束)，$g[fail[x]]$包含的dp值是蓝色位置。因此，$g[x]$实际上等于$g[fail[x]]$和多出来一个位置的dp之和，多出来的位置是$i-(len[slink[x]]+diff[x])$。最后再用$g[x]$去更新$dp[i]$，这部分等差数列的贡献就计算完毕了，不断跳$slink[x]$，重复这个过程即可。

![img](./pam6.png)

上述做法的正确性依赖于：如果$x$和$fail[x]$属于同一个等差数列，那么$fail[x]$上一次出现的位置是$i-diff[x]$。