# Manacher算法

Manacher算法用于解决求解字符串中所有回文子串的问题。

## 一、回文串信息的另一种表达方式

关于回文串的信息，可以使用一种更紧凑的方式表达：对于每个位置$i=0,1...n-1$，我们找出**以位置i为中心的==长度为奇数的回文串个数==**$d_1[i]$和**==长度为偶数的回文串个数==**$d_2[i]$。

如果以某个位置i为中心，我们以后一个长度为l的字符串，那么我们有以i为中心的长度为l-2,l-4等回文串。所以$d_1[i]$和$d_2[i]$两个数组已经足够表示字符串中所有子回文串的信息。

**存在复杂度为$O(n)$且足够简单的Mancher算法计算上述两个“回文性质数组”$d_1[]$ 和$d_2[]$**。

此外，使用字符串哈系，回文串问题可以在$O(n\log{n})$时间内解决，而使用后缀数组和快速LCA该问题可以在$O(n)$时间内解决。但是Manacher算法在时间、空间复杂度都拥有更小的常数。



## 二、代码实现

### 1.朴素算法—中心扩散算法

中心扩散算法：对每个中心位置i，在比较一对对应字符后，只要可能，该算法便尝试将答案加1。朴素算法的时间复杂度是$O(n^2)$。

```c++
vector<int> d1(n), d2(n);
for (int i = 0; i < n; i++) {
  d1[i] = 1;
  while (0 <= i - d1[i] && i + d1[i] < n && s[i - d1[i]] == s[i + d1[i]]) {
    d1[i]++;
  }

  // 计算偶数长度回文串，默认中心靠右
  d2[i] = 0;
  while (0 <= i - d2[i] - 1 && i + d2[i] < n &&
         s[i - d2[i] - 1] == s[i + d2[i]]) {
    d2[i]++;
  }
}
```



### 2. Manacher算法

对算法中寻找所有**奇数长度回文串的情况**进行介绍，即只计算$d_1[]$：

为了快速计算，我们维护已找到的最靠右的子回文串的边界$(l,r)$，即具有最大r值的回文串，其中l和r分别为该回文串左右边界的位置。初始时，我们置$l=0$和$r=-1$。

现在假设对下一个i计算$d_1[i]$，而之前所有$d_1[]$中的值已经计算完毕，那么按照下列方式计算：

+ **如果i位于当前子回文串之外，即$i\gt r$，那么就调用朴素算法(中心扩散算法)。**

  因此我们将连续地增加$d_1[i]$，同时在每一步中检查当前子串$[i-d_1[i],i+d_1[i]]$是否为一个回文串。如果我们找到了第一处对应字符不同，又或者碰到了s的边界，则算法停止。这两种情况下我们均已经计算完$d_1[i]$。此后，仍需记得更新$(l,r)$。

+ 如果$i\le r$，我们将尝试从已经计算过的$d_1[i]$的值中获取一些信息，首先在子回文串$(l,r)$中反转位置i,即我们得到$j=l+(r-i)$。现在来考察值$d_1[j]$。**因为位置j同位置i对称，我们几乎总是可以置$d_1[i]=d_1[j]$。**

  但是，当"内部回文串"到达"外部回文串"的边界时，即$j-d_1[j]+1\le l$(等价说即,$i+d_1[j]+1\ge r$)。因为在" 外部"回文串意外的对称性没有保证，因此直接置$d_1[i]=d_1[j]$是不正确的，因为我们没有足够的信息来断言在位置i的回文串具有同样的长度。为了**正确处理"内部回文串"到达"外部回文串"的边界的情况**，我们应当**"截断"回文串的长度，即$d_1[i]=r-i$，之后我们运行朴素算法。**

  我们仍需要在计算完每一个$d_1[i]$之后更新值$(l,r)$。



### 3. Manacher算法代码实现

```c++
#include<iostream>
#include<string>
#include<vector>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<algorithm>
using namespace std;

int main() {
    string s;
    getline(cin, s);
    int n = s.size();
    vector<int> d1(n);
    vector<int> d2(n);
    // 计算d1
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        // 判断i是否在(l,r)中，不在则赋值1,否则取d1[l + r - i]和r - i中较小者，这样兼顾到了截断操作
        int k = (i > r) ? 1 : min(d1[l + r - i], r - i);
        // 朴素的中心扩展算法
        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) k++;
        d1[i] = k--; // 因为下面是确定范围，所以要对k--。
        // 如果i + k超出了(l,r)那么就需要更新范围
        if (i + k > r) l = i - k, r = i + k;
    }
    
    for (int i = 0, l = 0, r = -1; i < n; i++) {
        int k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);
        while (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) k++;
        d2[i] = k--;
        if (i + k > r) l = i - k - 1, r = i + k;
    }
    return 0;
}
```





### 4.统一处理

实际情况中我们可以通过一个技巧将两者的计算统一为$d_1[]$的计算：

给定一个长度为n的字符串s，我们在其n + 1个空中插入分隔符#，从而构造一个长度为2n + 1的字符串$s^{'}$，对于字符串$s = abababc$,其对应的$s^{'}=\#a\#b\#a\#b\#a\#b\#c\#$。#就相当于s中的”空“，方便偶数长度回文串的处理。

可以注意到，对于s中一个以字母为中心的极大子回文串，设其长度为m + 1,那么其在$s^{'}$中对应一个以相应字母为中心，长度为$2m + 3$的极大子回文串; 而对于s中一个以空为中心的极大子回文串，设其长度为m，则其在$s^{'}$中对应一个以相应表示空的#为中心，长度为$2m + 1$的极大子回文串。**因此，可以得出，在$s^{'}$中，$d_1[i]$表示在s中对应位置为中心的极大子回文串的总长度加1。**